/Users/Timur.Kudashev/CLionProjects/FlowchartFutamura/mix.flowchart
{ read program, division, vs0; init: := residual '{}; := program parse program vs0; := pp0 lookupInitial program; := pendingLabels '(); := pending '((pp0$vs0)); := marked '(); goto cont_external; cont_external: := tmpDynamic hd pending; := pp hd tmpDynamic; := tmpDynamic tl tmpDynamic; := vs hd tmpDynamic; := tmpDynamic '(pp$vs); := marked cons tmpDynamic marked; := code initialCode pp vs program; := pending tl pending; := ppi pp0; := bb lookup pp0 program; := tmpDynamic == ppi pp; if tmpDynamic goto cont_internal else continue_lookup; continue_lookup: := ppi nextLabel ppi program pendingLabels; := bb lookup ppi program; := tmpDynamic == ppi pp; if tmpDynamic goto cont_internal else continue_lookup; cont_internal: := command firstCommand bb; := bb tl bb; := op hd command; := command tl command; := eqSymbol ':=; := tmpStatic == op eqSymbol; if tmpStatic goto do_assignment else cont1; do_assignment: := X hd command; := tmpStatic tl command; := exp hd tmpStatic; := tmpStatic isStatic division X; if tmpStatic goto do_assignment_static else do_assignment_dynamic; do_assignment_static: := tmpDynamic eval exp vs; := vs addToState vs X tmpDynamic; := tmpStatic isEmpty bb; if tmpStatic goto stop_internal else cont_internal; do_assignment_dynamic: := tmpDynamic reduce exp vs; := code extendAssignment code X tmpDynamic; := tmpStatic isEmpty bb; if tmpStatic goto stop_internal else cont_internal; do_goto: := tmpStatic hd command; := bb lookup tmpStatic program; := tmpStatic isEmpty bb; if tmpStatic goto stop_internal else cont_internal; do_if: := exp hd command; := tmpStatic tl command; := tmpStatic tl tmpStatic; := trueLabel hd tmpStatic; := tmpStatic tl tmpStatic; := tmpStatic tl tmpStatic; := falseLabel hd tmpStatic; := tmpStatic isStatic division exp; if tmpStatic goto do_if_static else do_if_dynamic; do_if_static: := tmpDynamic eval exp vs; if tmpDynamic goto do_if_static_true else do_if_static_false; do_if_static_true: := bb lookup trueLabel program; := tmpStatic isEmpty bb; if tmpStatic goto stop_internal else cont_internal; do_if_static_false: := bb lookup falseLabel program; := tmpStatic isEmpty bb; if tmpStatic goto stop_internal else cont_internal; do_if_dynamic: := tmpDynamic '(trueLabel$vs); := pendingLabels consUnique trueLabel pendingLabels; := pending consUniqueIfNotInWithStateCompression tmpDynamic pending marked program; := tmpDynamic '(falseLabel$vs); := pendingLabels consUnique falseLabel pendingLabels; := pending consUniqueIfNotInWithStateCompression tmpDynamic pending marked program; := tmpDynamic reduce exp vs; := code extendIf code tmpDynamic trueLabel falseLabel vs program; := tmpStatic isEmpty bb; if tmpStatic goto stop_internal else cont_internal; do_return: := exp hd command; := tmpDynamic reduce exp vs; := code extendReturn code tmpDynamic; := tmpStatic isEmpty bb; if tmpStatic goto stop_internal else cont_internal; cont1: := gotoSymbol 'goto; := tmpStatic == op gotoSymbol; if tmpStatic goto do_goto else cont2; cont2: := ifSymbol 'if; := tmpStatic == op ifSymbol; if tmpStatic goto do_if else cont3; cont3: := returnSymbol 'return; := tmpStatic == op returnSymbol; if tmpStatic goto do_return else fail; fail: := fail 'fail; return fail; stop_internal: := residual extendCode residual code; := tmpDynamic isEmpty pending; if tmpDynamic goto stop_external else cont_external; stop_external: return residual; }
(program$division$pp0$bb$command$X$exp$trueLabel$falseLabel$ppi$op$tmpStatic$eqSymbol$gotoSymbol$ifSymbol$returnSymbol$fail$pendingLabels)
[program${read Q, Right; init: := Qtail Q; := Left '(); := emptyProgram '<>; := rightCommand 'right; := leftCommand 'left; := writeCommand 'write; := gotoCommand 'goto; := ifCommand 'if; goto loop; loop: := conditionStatic == Qtail emptyProgram; if conditionStatic goto stop else cont; cont: := Instruction firstInstruction Qtail; := Qtail rest Qtail; := Operator hd Instruction; := conditionStatic == Operator rightCommand; if conditionStatic goto do_right else cont1; cont1: := conditionStatic == Operator leftCommand; if conditionStatic goto do_left else cont2; cont2: := conditionStatic == Operator writeCommand; if conditionStatic goto do_write else cont3; cont3: := conditionStatic == Operator gotoCommand; if conditionStatic goto do_goto else cont4; cont4: := conditionStatic == Operator ifCommand; if conditionStatic goto do_if else error; do_right: := tmpDynamic firstSym Right; := Left cons tmpDynamic Left; := Right tl Right; goto loop; do_left: := tmpDynamic firstSym Left; := Right cons tmpDynamic Right; := Left tl Left; goto loop; do_write: := tmpStatic tl Instruction; := Symbol hd tmpStatic; := tmpDynamic tl Right; := Right cons Symbol tmpDynamic; goto loop; do_goto: := tmpStatic tl Instruction; := Nextlabel hd tmpStatic; := Qtail newTail Nextlabel Q; goto loop; do_if: := tmpStatic tl Instruction; := Symbol hd tmpStatic; := tmpStatic tl Instruction; := tmpStatic tl tmpStatic; := tmpStatic tl tmpStatic; := Nextlabel hd tmpStatic; := tmpDynamic firstSym Right; := conditionDynamic == Symbol tmpDynamic; if conditionDynamic goto jump else loop; jump: := Qtail newTail Nextlabel Q; goto loop; error: := fail 'fail; return fail; stop: return Right;}$division$(Q$Qtail$Instruction$Operator$Symbol$Nextlabel$emptyProgram$rightCommand$leftCommand$writeCommand$gotoCommand$ifCommand$conditionStatic$tmpStatic$fail)]